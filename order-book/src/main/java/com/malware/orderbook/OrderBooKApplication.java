package com.malware.orderbook;

import com.malware.orderbook.dao.OrderType;
import com.malware.orderbook.dao.Orders;
import com.malware.orderbook.dao.Transaction;
import com.malware.orderbook.service.OrderBookService;
import com.malware.orderbook.service.TransactionService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.kafka.streams.kstream.KStream;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
import org.springframework.messaging.Message;
import org.springframework.messaging.support.MessageBuilder;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.scheduling.annotation.Scheduled;

import java.time.LocalDateTime;
import java.util.LinkedList;
import java.util.List;
import java.util.Objects;
import java.util.Random;
import java.util.function.Consumer;
import java.util.function.Supplier;

@Slf4j
@EnableScheduling
@RequiredArgsConstructor
@SpringBootApplication
public class OrderBooKApplication {
    private static long orderId = 0;

    private final Random r = new Random();

    private final OrderBookService orderBookService;

    private final TransactionService transactionService;

    LinkedList<Orders> buyOrders = new LinkedList<>(List.of(
            new Orders(++orderId, 1, 1, 1, 100, LocalDateTime.now(), OrderType.BUY, 1000),
            new Orders(++orderId, 2, 2, 1, 200, LocalDateTime.now(), OrderType.BUY, 1050),
            new Orders(++orderId, 3, 3, 1, 100, LocalDateTime.now(), OrderType.BUY, 1030),
            new Orders(++orderId, 4, 4, 1, 200, LocalDateTime.now(), OrderType.BUY, 1050),
            new Orders(++orderId, 5, 5, 1, 200, LocalDateTime.now(), OrderType.BUY, 1000),
            new Orders(++orderId, 6, 12, 1, 100, LocalDateTime.now(), OrderType.BUY, 1050)
    ));

    LinkedList<Orders> sellOrders = new LinkedList<>(List.of(
            new Orders(++orderId, 7, 6, 1, 200, LocalDateTime.now(), OrderType.SELL, 950),
            new Orders(++orderId, 8, 7, 1, 100, LocalDateTime.now(), OrderType.SELL, 1000),
            new Orders(++orderId, 9, 8, 1, 100, LocalDateTime.now(), OrderType.SELL, 1050),
            new Orders(++orderId, 10, 9, 1, 300, LocalDateTime.now(), OrderType.SELL, 1000),
            new Orders(++orderId, 11, 10, 1, 200, LocalDateTime.now(), OrderType.SELL, 1020)
    ));

    public static void main(String[] args) {
        SpringApplication.run(OrderBooKApplication.class, args);
    }

    @Bean
    public Supplier<Message<Orders>> orderBuySupplier() {
        return () -> {
            if (buyOrders.peek() != null) {
                Message<Orders> o = MessageBuilder
                        .withPayload(buyOrders.peek())
                        .setHeader("kafka_messageKey", Objects.requireNonNull(buyOrders.poll()).getId())
                        .build();
                 orderBookService.addOrder(o.getPayload());
                return o;
            } else {
                return null;
            }
        };
    }

    @Bean
    public Supplier<Message<Orders>> orderSellSupplier() {
        return () -> {
            if (sellOrders.peek() != null) {
                Message<Orders> o = MessageBuilder
                        .withPayload(sellOrders.peek())
                        .setHeader("kafka_messageKey", Objects.requireNonNull(sellOrders.poll()).getId())
                        .build();
                 orderBookService.addOrder(o.getPayload());
                return o;
            } else {
                return null;
            }
        };
    }

    @Bean
    public Consumer<KStream<Integer, Transaction>> transactionConsumer() {
        return (k) -> k.peek(((key, value) -> transactionService.add(value)));
    }

    @Scheduled(cron = "* * * * * *")
    private void addOrder() {
        int i = new Random().nextInt(10, Integer.MAX_VALUE);
        if (r.nextBoolean()) {
            Orders order = new Orders(++orderId, i, 1, 1, 100, LocalDateTime.now(), OrderType.BUY, 1000);
            this.buyOrders.add(order);
        } else {
            Orders order = new Orders(++orderId, i, 1, 1, 100, LocalDateTime.now(), OrderType.SELL, 1000);
            this.sellOrders.add(order);
        }
    }
}
